#!/usr/bin/env python3
"""
RLC Low-Pass Filter Circuit Analysis and Visualization
======================================================

This script creates comprehensive, publication-quality plots for RLC circuit analysis.
Reads data from rlc_data.csv generated by the Fortran DOPRI5 solver.

Features:
- Time-domain response plots
- Phase portraits 
- Power analysis
- Frequency response (theoretical)
- Energy storage analysis
- Interactive 3D visualization
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from matplotlib.gridspec import GridSpec
from mpl_toolkits.mplot3d import Axes3D
import seaborn as sns
from scipy import signal
import warnings
warnings.filterwarnings('ignore')

# Set style for publication-quality plots
plt.style.use('seaborn-v0_8-darkgrid')
sns.set_palette("husl")
plt.rcParams.update({
    'font.size': 11,
    'font.family': 'serif',
    'figure.facecolor': 'white',
    'axes.facecolor': '#f8f9fa',
    'axes.edgecolor': '#dee2e6',
    'axes.linewidth': 1.2,
    'grid.alpha': 0.3,
    'lines.linewidth': 2.5,
    'lines.markersize': 8
})

class RLCAnalyzer:
    def __init__(self, csv_file='rlc_data.csv'):
        """Initialize the RLC circuit analyzer."""
        self.data = pd.read_csv(csv_file)
        self.extract_parameters()
        
    def extract_parameters(self):
        """Extract circuit parameters from the data."""
        # Circuit parameters (from the Fortran code)
        self.Vb = 24.0    # Input voltage (V)
        self.L = 1.0      # Inductance (H) 
        self.R = 100.0    # Resistance (Ω)
        self.C = 1e-3     # Capacitance (F)
        
        # Calculated parameters
        self.omega_n = 1.0 / np.sqrt(self.L * self.C)  # Natural frequency
        self.zeta = 0.5 * self.R * np.sqrt(self.C / self.L)  # Damping ratio
        self.tau = self.L / self.R  # Time constant
        self.f_n = self.omega_n / (2 * np.pi)  # Natural frequency in Hz
        
        print(f"Circuit Parameters:")
        print(f"  Vb = {self.Vb} V")
        print(f"  L = {self.L} H") 
        print(f"  R = {self.R} Ω")
        print(f"  C = {self.C*1000} mF")
        print(f"  ωn = {self.omega_n:.2f} rad/s")
        print(f"  fn = {self.f_n:.2f} Hz")
        print(f"  ζ = {self.zeta:.3f}")
        print(f"  τ = {self.tau*1000:.1f} ms")
        
    def create_comprehensive_plots(self):
        """Create a comprehensive set of analysis plots."""
        fig = plt.figure(figsize=(20, 16))
        fig.suptitle('RLC Low-Pass Filter Circuit Analysis', fontsize=20, fontweight='bold', y=0.95)
        
        # Create complex grid layout
        gs = GridSpec(4, 4, figure=fig, hspace=0.3, wspace=0.3)
        
        # 1. Time domain response (large plot)
        self.plot_time_response(fig, gs[0, :2])
        
        # 2. Current components
        self.plot_current_analysis(fig, gs[0, 2:])
        
        # 3. Phase portrait
        self.plot_phase_portrait(fig, gs[1, 0])
        
        # 4. Power analysis
        self.plot_power_analysis(fig, gs[1, 1])
        
        # 5. Energy analysis
        self.plot_energy_analysis(fig, gs[1, 2])
        
        # 6. Circuit diagram
        self.plot_circuit_diagram(fig, gs[1, 3])
        
        # 7. Frequency response (theoretical)
        self.plot_frequency_response(fig, gs[2, :2])
        
        # 8. Step response characteristics
        self.plot_step_characteristics(fig, gs[2, 2:])
        
        # 9. 3D trajectory
        self.plot_3d_trajectory(fig, gs[3, :2])
        
        # 10. Statistical analysis
        self.plot_statistics(fig, gs[3, 2:])
        
        plt.tight_layout()
        plt.savefig('rlc_analysis.png', dpi=300, bbox_inches='tight', facecolor='white')
        plt.show()
        
    def plot_time_response(self, fig, gs_pos):
        """Plot voltage and current vs time."""
        ax = fig.add_subplot(gs_pos)
        
        t = self.data['Time'] * 1000  # Convert to ms
        
        # Plot voltage
        ax.plot(t, self.data['Voltage'], 'b-', linewidth=3, label='Voltage (V)', alpha=0.8)
        ax.set_ylabel('Voltage (V)', color='b', fontweight='bold')
        ax.tick_params(axis='y', labelcolor='b')
        ax.grid(True, alpha=0.3)
        
        # Create secondary y-axis for current
        ax2 = ax.twinx()
        ax2.plot(t, self.data['Current_L']*1000, 'r-', linewidth=3, label='Current (mA)', alpha=0.8)
        ax2.set_ylabel('Current (mA)', color='r', fontweight='bold')
        ax2.tick_params(axis='y', labelcolor='r')
        
        # Add settling time markers
        settling_time = 5 * self.tau * 1000  # 5τ in ms
        ax.axvline(settling_time, color='gray', linestyle='--', alpha=0.7, label=f'5τ = {settling_time:.1f} ms')
        
        # Add steady state value
        ax.axhline(self.Vb, color='gray', linestyle=':', alpha=0.7, label=f'Steady State = {self.Vb} V')
        
        ax.set_xlabel('Time (ms)', fontweight='bold')
        ax.set_title('Time Domain Response', fontsize=14, fontweight='bold')
        ax.legend(loc='lower right')
        
        # Add annotations
        max_current_idx = np.argmax(self.data['Current_L'])
        max_current_time = self.data['Time'].iloc[max_current_idx] * 1000
        max_current_val = self.data['Current_L'].iloc[max_current_idx] * 1000
        
        ax2.annotate(f'Peak: {max_current_val:.1f} mA\nat {max_current_time:.2f} ms',
                    xy=(max_current_time, max_current_val), xytext=(max_current_time + 5, max_current_val + 20),
                    arrowprops=dict(arrowstyle='->', color='red', alpha=0.7),
                    fontsize=10, color='red')
        
    def plot_current_analysis(self, fig, gs_pos):
        """Plot current components breakdown."""
        ax = fig.add_subplot(gs_pos)
        
        t = self.data['Time'] * 1000
        
        ax.plot(t, self.data['Current_L']*1000, 'r-', linewidth=2.5, label='Inductor Current (iL)')
        ax.plot(t, self.data['Current_R']*1000, 'g-', linewidth=2.5, label='Resistor Current (iR)')
        ax.plot(t, self.data['Current_C']*1000, 'orange', linewidth=2.5, label='Capacitor Current (iC)')
        
        ax.set_xlabel('Time (ms)', fontweight='bold')
        ax.set_ylabel('Current (mA)', fontweight='bold')
        ax.set_title('Current Components Analysis', fontsize=14, fontweight='bold')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        # Highlight the relationship iL = iR + iC
        ax.text(0.05, 0.95, 'Kirchhoff\'s Law:\niL = iR + iC', transform=ax.transAxes,
                bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.8),
                verticalalignment='top', fontsize=10)
        
    def plot_phase_portrait(self, fig, gs_pos):
        """Plot phase portrait (V vs dV/dt)."""
        ax = fig.add_subplot(gs_pos)
        
        V = self.data['Voltage']
        # Calculate dV/dt numerically
        dt = np.diff(self.data['Time'])
        dVdt = np.diff(V) / dt
        
        # Create colormap based on time
        colors = plt.cm.plasma(np.linspace(0, 1, len(dVdt)))
        
        for i in range(len(dVdt)-1):
            ax.plot(V.iloc[i:i+2], dVdt[i:i+2], color=colors[i], linewidth=2, alpha=0.7)
        
        # Mark start and end points
        ax.plot(V.iloc[0], dVdt[0], 'go', markersize=10, label='Start', markeredgecolor='black')
        ax.plot(V.iloc[-2], dVdt[-1], 'ro', markersize=10, label='End', markeredgecolor='black')
        
        ax.set_xlabel('Voltage (V)', fontweight='bold')
        ax.set_ylabel('dV/dt (V/s)', fontweight='bold')
        ax.set_title('Phase Portrait', fontsize=14, fontweight='bold')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
    def plot_power_analysis(self, fig, gs_pos):
        """Plot power consumption and generation."""
        ax = fig.add_subplot(gs_pos)
        
        t = self.data['Time'] * 1000
        
        ax.plot(t, self.data['Power_R'], 'r-', linewidth=2.5, label='Power in R')
        ax.plot(t, self.data['Power_Total'], 'b-', linewidth=2.5, label='Total Power')
        ax.fill_between(t, 0, self.data['Power_R'], alpha=0.3, color='red')
        
        ax.set_xlabel('Time (ms)', fontweight='bold')
        ax.set_ylabel('Power (W)', fontweight='bold')
        ax.set_title('Power Analysis', fontsize=14, fontweight='bold')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        # Add efficiency annotation
        final_power_R = self.data['Power_R'].iloc[-1]
        final_power_total = self.data['Power_Total'].iloc[-1]
        efficiency = (final_power_R / final_power_total * 100) if final_power_total != 0 else 0
        
        ax.text(0.05, 0.95, f'Final Efficiency:\n{efficiency:.1f}%', transform=ax.transAxes,
                bbox=dict(boxstyle='round', facecolor='lightyellow', alpha=0.8),
                verticalalignment='top', fontsize=10)
        
    def plot_energy_analysis(self, fig, gs_pos):
        """Plot energy storage in L and C."""
        ax = fig.add_subplot(gs_pos)
        
        t = self.data['Time'] * 1000
        
        # Calculate energy stored
        E_L = 0.5 * self.L * self.data['Current_L']**2 * 1000  # Convert to mJ
        E_C = 0.5 * self.C * self.data['Voltage']**2 * 1000   # Convert to mJ
        E_total = E_L + E_C
        
        ax.plot(t, E_L, 'b-', linewidth=2.5, label='Magnetic Energy (L)')
        ax.plot(t, E_C, 'r-', linewidth=2.5, label='Electric Energy (C)')
        ax.plot(t, E_total, 'k--', linewidth=2, label='Total Energy')
        
        ax.fill_between(t, 0, E_L, alpha=0.3, color='blue')
        ax.fill_between(t, E_L, E_total, alpha=0.3, color='red')
        
        ax.set_xlabel('Time (ms)', fontweight='bold')
        ax.set_ylabel('Energy (mJ)', fontweight='bold')
        ax.set_title('Energy Storage', fontsize=14, fontweight='bold')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
    def plot_circuit_diagram(self, fig, gs_pos):
        """Draw a circuit diagram."""
        ax = fig.add_subplot(gs_pos)
        ax.set_xlim(0, 10)
        ax.set_ylim(0, 6)
        ax.set_aspect('equal')
        
        # Draw circuit elements
        # Voltage source
        circle = patches.Circle((1, 3), 0.5, linewidth=2, edgecolor='black', facecolor='lightblue')
        ax.add_patch(circle)
        ax.text(1, 3, f'{self.Vb}V', ha='center', va='center', fontweight='bold')
        
        # Inductor
        ax.plot([2.5, 3.5], [4.5, 4.5], 'k-', linewidth=3)
        for i in range(4):
            x = 2.8 + i * 0.15
            arc = patches.Arc((x, 4.5), 0.3, 0.6, angle=0, theta1=0, theta2=180, linewidth=2)
            ax.add_patch(arc)
        ax.text(3, 5.2, f'L={self.L}H', ha='center', fontweight='bold')
        
        # Resistor
        rect = patches.Rectangle((6, 4.3), 1, 0.4, linewidth=2, edgecolor='black', facecolor='lightcoral')
        ax.add_patch(rect)
        ax.text(6.5, 5.2, f'R={self.R}Ω', ha='center', fontweight='bold')
        
        # Capacitor
        ax.plot([6.3, 6.3], [2.5, 1.5], 'k-', linewidth=3)
        ax.plot([6.7, 6.7], [2.5, 1.5], 'k-', linewidth=3)
        ax.text(6.5, 0.8, f'C={self.C*1000}mF', ha='center', fontweight='bold')
        
        # Connections
        ax.plot([1.5, 2.5], [3, 4.5], 'k-', linewidth=2)  # Source to L
        ax.plot([3.5, 6], [4.5, 4.5], 'k-', linewidth=2)   # L to R
        ax.plot([7, 8], [4.5, 4.5], 'k-', linewidth=2)     # R to right
        ax.plot([8, 8], [4.5, 2], 'k-', linewidth=2)       # Right down
        ax.plot([8, 6.5], [2, 2], 'k-', linewidth=2)       # To C
        ax.plot([6.5, 1], [1.5, 1.5], 'k-', linewidth=2)   # C to source
        ax.plot([1, 1], [1.5, 2.5], 'k-', linewidth=2)     # Source bottom
        
        # Current arrows
        ax.annotate('', xy=(4, 4.8), xytext=(3, 4.8), 
                   arrowprops=dict(arrowstyle='->', color='red', lw=2))
        ax.text(3.5, 5.5, 'iL', ha='center', color='red', fontweight='bold')
        
        ax.set_title('RLC Low-Pass Filter', fontsize=14, fontweight='bold')
        ax.axis('off')
        
    def plot_frequency_response(self, fig, gs_pos):
        """Plot theoretical frequency response."""
        ax = fig.add_subplot(gs_pos)
        
        # Frequency range
        f = np.logspace(-1, 4, 1000)  # 0.1 Hz to 10 kHz
        omega = 2 * np.pi * f
        
        # Transfer function H(jω) = 1 / (1 + jωRC + (jω)²LC)
        s = 1j * omega
        H = 1 / (1 + s * self.R * self.C + s**2 * self.L * self.C)
        
        # Magnitude and phase
        mag_db = 20 * np.log10(np.abs(H))
        phase_deg = np.angle(H) * 180 / np.pi
        
        # Plot magnitude
        ax.semilogx(f, mag_db, 'b-', linewidth=3, label='Magnitude')
        ax.set_ylabel('Magnitude (dB)', color='b', fontweight='bold')
        ax.tick_params(axis='y', labelcolor='b')
        ax.grid(True, alpha=0.3)
        
        # Mark -3dB frequency
        cutoff_freq = self.omega_n / (2 * np.pi)
        ax.axvline(cutoff_freq, color='red', linestyle='--', alpha=0.7, 
                  label=f'fn = {cutoff_freq:.1f} Hz')
        ax.axhline(-3, color='gray', linestyle=':', alpha=0.7, label='-3dB')
        
        # Phase on secondary axis
        ax2 = ax.twinx()
        ax2.semilogx(f, phase_deg, 'r--', linewidth=2, label='Phase', alpha=0.8)
        ax2.set_ylabel('Phase (°)', color='r', fontweight='bold')
        ax2.tick_params(axis='y', labelcolor='r')
        
        ax.set_xlabel('Frequency (Hz)', fontweight='bold')
        ax.set_title('Frequency Response (Theoretical)', fontsize=14, fontweight='bold')
        ax.legend(loc='upper left')
        ax2.legend(loc='upper right')
        
    def plot_step_characteristics(self, fig, gs_pos):
        """Plot step response characteristics."""
        ax = fig.add_subplot(gs_pos)
        
        t = self.data['Time'] * 1000
        V = self.data['Voltage']
        
        # Normalize to final value for analysis
        V_final = V.iloc[-1]
        V_norm = V / V_final
        
        ax.plot(t, V_norm, 'b-', linewidth=3, label='Normalized Response')
        
        # Mark important points
        # 10% and 90% rise time
        idx_10 = np.argmax(V_norm >= 0.1)
        idx_90 = np.argmax(V_norm >= 0.9)
        rise_time = (self.data['Time'].iloc[idx_90] - self.data['Time'].iloc[idx_10]) * 1000
        
        ax.axhline(0.1, color='gray', linestyle=':', alpha=0.7)
        ax.axhline(0.9, color='gray', linestyle=':', alpha=0.7)
        ax.axvline(t.iloc[idx_10], color='green', linestyle='--', alpha=0.7)
        ax.axvline(t.iloc[idx_90], color='green', linestyle='--', alpha=0.7)
        
        # Settling time (within 2% of final value)
        settling_idx = np.where(np.abs(V_norm - 1) <= 0.02)[0]
        if len(settling_idx) > 0:
            settling_time = t.iloc[settling_idx[0]]
            ax.axvline(settling_time, color='red', linestyle='--', alpha=0.7, 
                      label=f'Settling Time = {settling_time:.1f} ms')
        
        ax.set_xlabel('Time (ms)', fontweight='bold')
        ax.set_ylabel('Normalized Response', fontweight='bold')
        ax.set_title('Step Response Characteristics', fontsize=14, fontweight='bold')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        # Add text box with characteristics
        char_text = f'Rise Time: {rise_time:.2f} ms\n'
        char_text += f'Damping: ζ = {self.zeta:.3f}\n'
        char_text += f'Type: {"Overdamped" if self.zeta > 1 else "Underdamped" if self.zeta < 1 else "Critical"}'
        
        ax.text(0.05, 0.95, char_text, transform=ax.transAxes,
                bbox=dict(boxstyle='round', facecolor='lightgreen', alpha=0.8),
                verticalalignment='top', fontsize=10)
        
    def plot_3d_trajectory(self, fig, gs_pos):
        """Plot 3D trajectory in state space."""
        ax = fig.add_subplot(gs_pos, projection='3d')
        
        V = self.data['Voltage']
        I = self.data['Current_L']
        t = self.data['Time']
        
        # Create color gradient
        colors = plt.cm.viridis(np.linspace(0, 1, len(t)))
        
        # Plot trajectory
        for i in range(len(t)-1):
            ax.plot(V.iloc[i:i+2], I.iloc[i:i+2], t.iloc[i:i+2], 
                   color=colors[i], linewidth=2, alpha=0.8)
        
        # Mark start and end
        ax.scatter(V.iloc[0], I.iloc[0], t.iloc[0], color='green', s=100, label='Start')
        ax.scatter(V.iloc[-1], I.iloc[-1], t.iloc[-1], color='red', s=100, label='End')
        
        ax.set_xlabel('Voltage (V)', fontweight='bold')
        ax.set_ylabel('Current (A)', fontweight='bold')
        ax.set_zlabel('Time (s)', fontweight='bold')
        ax.set_title('3D State Space Trajectory', fontsize=14, fontweight='bold')
        ax.legend()
        
    def plot_statistics(self, fig, gs_pos):
        """Plot statistical analysis and summary."""
        ax = fig.add_subplot(gs_pos)
        ax.axis('off')
        
        # Calculate statistics
        V = self.data['Voltage']
        I = self.data['Current_L']
        t = self.data['Time']
        
        # Summary statistics
        stats = {
            'Final Voltage': f'{V.iloc[-1]:.3f} V',
            'Peak Current': f'{I.max()*1000:.1f} mA',
            'Final Current': f'{I.iloc[-1]*1000:.3f} mA',
            'Energy Dissipated': f'{np.trapz(self.data["Power_R"], t):.3f} J',
            'Max Power': f'{self.data["Power_R"].max():.3f} W',
            'Settling Time (5τ)': f'{5*self.tau*1000:.1f} ms',
            'Rise Time (10%-90%)': 'Calculated above',
            'System Type': 'Overdamped' if self.zeta > 1 else 'Underdamped' if self.zeta < 1 else 'Critical'
        }
        
        # Create summary table
        y_pos = 0.9
        ax.text(0.05, y_pos, 'Circuit Analysis Summary', fontsize=16, fontweight='bold', 
                transform=ax.transAxes)
        
        y_pos -= 0.1
        for key, value in stats.items():
            ax.text(0.05, y_pos, f'{key}:', fontweight='bold', transform=ax.transAxes)
            ax.text(0.55, y_pos, f'{value}', transform=ax.transAxes)
            y_pos -= 0.08
            
        # Add performance metrics
        y_pos -= 0.05
        ax.text(0.05, y_pos, 'Performance Metrics', fontsize=14, fontweight='bold', 
                transform=ax.transAxes)
        
        y_pos -= 0.08
        settling_error = abs(V.iloc[-1] - self.Vb) / self.Vb * 100
        ax.text(0.05, y_pos, f'Settling Error: {settling_error:.2f}%', transform=ax.transAxes)
        
        y_pos -= 0.06
        overshoot = (V.max() - self.Vb) / self.Vb * 100 if V.max() > self.Vb else 0
        ax.text(0.05, y_pos, f'Overshoot: {overshoot:.2f}%', transform=ax.transAxes)
        
        # Add circuit diagram annotation
        y_pos -= 0.08
        ax.text(0.05, y_pos, 'Circuit Behavior:', fontsize=12, fontweight='bold', 
                transform=ax.transAxes)
        y_pos -= 0.06
        behavior = "Smooth exponential approach\nto steady state (no oscillation)"
        ax.text(0.05, y_pos, behavior, transform=ax.transAxes, fontsize=10)
        
    def create_interactive_plots(self):
        """Create additional interactive-style plots."""
        # Create a second figure for additional analysis
        fig, axes = plt.subplots(2, 3, figsize=(18, 12))
        fig.suptitle('Extended RLC Circuit Analysis', fontsize=16, fontweight='bold')
        
        try:
            # 1. Current density plot
            print("Creating current density plot...")
            self.plot_current_density(axes[0, 0])
            
            # 2. Impedance vs frequency
            print("Creating impedance analysis...")
            self.plot_impedance_analysis(axes[0, 1])
            
            # 3. Energy flow diagram
            print("Creating energy flow plot...")
            self.plot_energy_flow(axes[0, 2])
            
            # 4. Settling behavior
            print("Creating settling analysis...")
            self.plot_settling_analysis(axes[1, 0])
            
            # 5. Power spectral density
            print("Creating power spectrum...")
            self.plot_power_spectrum(axes[1, 1])
            
            # 6. Parameter sensitivity
            print("Creating parameter sensitivity...")
            self.plot_parameter_sensitivity(axes[1, 2])
            
        except Exception as e:
            print(f"Error in extended plots: {e}")
            print(f"Data shape: {self.data.shape}")
            print(f"Data columns: {self.data.columns.tolist()}")
            return
        
        plt.tight_layout()
        plt.savefig('rlc_extended_analysis.png', dpi=300, bbox_inches='tight', facecolor='white')
        plt.show()
        
    def plot_current_density(self, ax):
        """Plot current density over time."""
        t = self.data['Time'] * 1000
        
        # Stack the current data properly
        I_L = self.data['Current_L'] * 1000
        I_R = self.data['Current_R'] * 1000  
        I_C = self.data['Current_C'] * 1000
        
        # Create 2D array for heatmap
        I_matrix = np.array([I_L, I_R, I_C])
        
        im = ax.imshow(I_matrix, aspect='auto', cmap='RdYlBu_r', 
                      extent=[t.min(), t.max(), -0.5, 2.5])
        
        ax.set_xlabel('Time (ms)')
        ax.set_ylabel('Current Type')
        ax.set_yticks([0, 1, 2])
        ax.set_yticklabels(['iL', 'iR', 'iC'])
        ax.set_title('Current Components Heatmap')
        
        cbar = plt.colorbar(im, ax=ax)
        cbar.set_label('Current (mA)')
        
    def plot_impedance_analysis(self, ax):
        """Plot impedance magnitude and phase."""
        f = np.logspace(-1, 4, 1000)
        omega = 2 * np.pi * f
        
        # Total impedance Z = R + jωL + 1/(jωC)
        Z = self.R + 1j * omega * self.L + 1 / (1j * omega * self.C)
        Z_mag = np.abs(Z)
        Z_phase = np.angle(Z) * 180 / np.pi
        
        ax.semilogx(f, Z_mag, 'b-', linewidth=3, label='|Z|')
        ax.set_ylabel('Impedance Magnitude (Ω)', color='b')
        ax.tick_params(axis='y', labelcolor='b')
        
        ax2 = ax.twinx()
        ax2.semilogx(f, Z_phase, 'r--', linewidth=2, label='∠Z')
        ax2.set_ylabel('Phase (°)', color='r')
        ax2.tick_params(axis='y', labelcolor='r')
        
        ax.set_xlabel('Frequency (Hz)')
        ax.set_title('Circuit Impedance')
        ax.grid(True, alpha=0.3)
        ax.legend(loc='upper left')
        ax2.legend(loc='upper right')
        
    def plot_energy_flow(self, ax):
        """Plot energy flow and conservation."""
        t = self.data['Time'] * 1000
        
        # Energy calculations
        E_L = 0.5 * self.L * self.data['Current_L']**2 * 1000
        E_C = 0.5 * self.C * self.data['Voltage']**2 * 1000
        
        # Calculate cumulative energy dissipated more carefully
        if len(self.data) > 1:
            dt_vals = np.diff(self.data['Time'])
            power_vals = self.data['Power_R'].iloc[:-1].values
            E_dissipated_diff = power_vals * dt_vals * 1000  # Convert to mJ
            E_dissipated = np.concatenate([[0], np.cumsum(E_dissipated_diff)])
        else:
            E_dissipated = np.zeros_like(E_L)
        
        # Ensure all arrays have the same length
        min_len = min(len(E_L), len(E_C), len(E_dissipated))
        E_L = E_L[:min_len]
        E_C = E_C[:min_len]
        E_dissipated = E_dissipated[:min_len]
        t_plot = t[:min_len]
        
        ax.stackplot(t_plot, E_L, E_C, E_dissipated, 
                    labels=['Magnetic (L)', 'Electric (C)', 'Dissipated (R)'],
                    colors=['blue', 'red', 'gray'], alpha=0.7)
        
        ax.set_xlabel('Time (ms)')
        ax.set_ylabel('Energy (mJ)')
        ax.set_title('Energy Flow and Conservation')
        ax.legend(loc='upper right')
        ax.grid(True, alpha=0.3)
        
    def plot_settling_analysis(self, ax):
        """Detailed settling behavior analysis."""
        t = self.data['Time'] * 1000
        V = self.data['Voltage']
        V_final = self.Vb
        
        # Calculate settling envelope
        error = np.abs(V - V_final) / V_final * 100
        
        ax.semilogy(t, error, 'b-', linewidth=3, label='Settling Error')
        
        # Add tolerance bands
        tolerances = [5, 2, 1]
        colors = ['red', 'orange', 'green']
        
        for tol, color in zip(tolerances, colors):
            ax.axhline(tol, color=color, linestyle='--', alpha=0.7, label=f'{tol}% tolerance')
            
            # Find settling time for this tolerance
            settled_idx = np.where(error <= tol)[0]
            if len(settled_idx) > 0:
                settling_time = t.iloc[settled_idx[0]]
                ax.axvline(settling_time, color=color, linestyle=':', alpha=0.5)
                ax.text(settling_time, tol*2, f'{settling_time:.1f}ms', 
                       rotation=90, color=color, fontsize=9)
        
        ax.set_xlabel('Time (ms)')
        ax.set_ylabel('Settling Error (%)')
        ax.set_title('Settling Behavior Analysis')
        ax.legend()
        ax.grid(True, alpha=0.3)
        
    def plot_power_spectrum(self, ax):
        """Plot power spectral density."""
        from scipy.signal import welch
        
        # Calculate PSD of voltage signal
        fs = 1 / np.diff(self.data['Time']).mean()  # Sampling frequency
        f, Pxx = welch(self.data['Voltage'], fs, nperseg=min(256, len(self.data)//4))
        
        ax.semilogx(f, 10*np.log10(Pxx), 'b-', linewidth=2)
        ax.set_xlabel('Frequency (Hz)')
        ax.set_ylabel('PSD (dB/Hz)')
        ax.set_title('Power Spectral Density')
        ax.grid(True, alpha=0.3)
        
        # Mark natural frequency
        ax.axvline(self.f_n, color='red', linestyle='--', alpha=0.7, 
                  label=f'fn = {self.f_n:.1f} Hz')
        ax.legend()
        
    def plot_parameter_sensitivity(self, ax):
        """Show parameter sensitivity analysis."""
        # Theoretical analysis of how parameters affect response
        params = ['L', 'R', 'C']
        base_values = [self.L, self.R, self.C]
        
        # Calculate how ωn and ζ change with ±20% parameter variation
        variations = []
        
        for i, (param, base_val) in enumerate(zip(params, base_values)):
            omega_plus = omega_minus = 0
            zeta_plus = zeta_minus = 0
            
            if param == 'L':
                L_plus, L_minus = base_val * 1.2, base_val * 0.8
                omega_plus = 1 / np.sqrt(L_plus * self.C)
                omega_minus = 1 / np.sqrt(L_minus * self.C)
                zeta_plus = 0.5 * self.R * np.sqrt(self.C / L_plus)
                zeta_minus = 0.5 * self.R * np.sqrt(self.C / L_minus)
            elif param == 'R':
                R_plus, R_minus = base_val * 1.2, base_val * 0.8
                omega_plus = omega_minus = self.omega_n
                zeta_plus = 0.5 * R_plus * np.sqrt(self.C / self.L)
                zeta_minus = 0.5 * R_minus * np.sqrt(self.C / self.L)
            elif param == 'C':
                C_plus, C_minus = base_val * 1.2, base_val * 0.8
                omega_plus = 1 / np.sqrt(self.L * C_plus)
                omega_minus = 1 / np.sqrt(self.L * C_minus)
                zeta_plus = 0.5 * self.R * np.sqrt(C_plus / self.L)
                zeta_minus = 0.5 * self.R * np.sqrt(C_minus / self.L)
            
            variations.append({
                'param': param,
                'omega_change': [(omega_plus - self.omega_n)/self.omega_n * 100,
                                (omega_minus - self.omega_n)/self.omega_n * 100],
                'zeta_change': [(zeta_plus - self.zeta)/self.zeta * 100,
                               (zeta_minus - self.zeta)/self.zeta * 100]
            })
        
        # Plot sensitivity bars
        x = np.arange(len(params))
        width = 0.35
        
        omega_sens = [max(abs(v['omega_change'][0]), abs(v['omega_change'][1])) for v in variations]
        zeta_sens = [max(abs(v['zeta_change'][0]), abs(v['zeta_change'][1])) for v in variations]
        
        bars1 = ax.bar(x - width/2, omega_sens, width, label='ωn sensitivity', color='blue', alpha=0.7)
        bars2 = ax.bar(x + width/2, zeta_sens, width, label='ζ sensitivity', color='red', alpha=0.7)
        
        ax.set_xlabel('Parameter')
        ax.set_ylabel('Sensitivity (% change)')
        ax.set_title('Parameter Sensitivity Analysis')
        ax.set_xticks(x)
        ax.set_xticklabels(params)
        ax.legend()
        ax.grid(True, alpha=0.3)
        
        # Add value labels on bars
        for bar in bars1:
            height = bar.get_height()
            ax.text(bar.get_x() + bar.get_width()/2., height + 0.5,
                   f'{height:.1f}%', ha='center', va='bottom', fontsize=9)
        
        for bar in bars2:
            height = bar.get_height()
            ax.text(bar.get_x() + bar.get_width()/2., height + 0.5,
                   f'{height:.1f}%', ha='center', va='bottom', fontsize=9)

def main():
    """Main function to run the complete analysis."""
    print("RLC Low-Pass Filter Circuit Analysis")
    print("=" * 40)
    
    try:
        # Initialize analyzer
        analyzer = RLCAnalyzer('rlc_data.csv')
        
        print("\nGenerating comprehensive analysis plots...")
        analyzer.create_comprehensive_plots()
        
        print("\nGenerating extended analysis plots...")
        analyzer.create_interactive_plots()
        
        print("\nAnalysis complete! Generated files:")
        print("  - rlc_analysis.png (main analysis)")
        print("  - rlc_extended_analysis.png (extended analysis)")
        
    except FileNotFoundError:
        print("Error: rlc_data.csv not found!")
        print("Please run the Fortran program first to generate the data file.")
    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    main()